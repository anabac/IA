2.1
Implementamos la función lógica xnor, que devuelve T si y sólo si sus dos argumentos son T o los dos son NIL. Esto nos servirá para comprobar si dos números tienen el mismo signo, ya que los signos los representaremos como booleanos (T: +, NIL: -).
El cuerpo de bisect es un gran cond que comprueba primero si a o b ya son 0, o si da la casualidad de que su punto medio sea 0, en cuyo caso ya hemos encontrado la raíz.
Si ninguno lo es, entonces mira qué extremo del intervalo tiene distinto signo que el punto medio al aplicarles la función, y se llama a sí misma recursivamente con el punto medio y el extremo elegido, como nuevos extremos de intervalo.

2.2
Ahora queremos hacer lo mismo que en la función anterior, solo que para todos los elementos de una lista, así que el primer impulso es usar mapcar para conseguirlo.
Sin embargo, si en alguno de estos intervalos no se encuentra raíz, bisect devolverá NIL. Como no queremos que aparezcan NIL en la solución, en lugar de usar mapcar recorremos la lista recursivamente, comprobamos el resultado de bisect para cada par y sólo lo añadimos si no es NIL.

2.3
Como nos piden dividir el intervalo en 2^N trozos, pensamos en dividir recursivamente el intervalo en mitades N veces. Utilizando el propio argumento N de la función como contador, sabemos cuándo parar la recursión. Cuando llega a 0, aplicamos bisec al fragmento de intervalo resultante, y se irán concatenando los raíces encontradas.
De nuevo, para evitar que se cuelen NIL, los filtramos en este paso.


3.1
Para solucionar este ejercicio, basta con aplicar (list elt e) a cada elemento e de la lista. Esto lo hacemos utilizando mapcar con una lambda que cumple esa función.

3.2
Tenemos que hacer lo que en la funcion anterior, pero para cada elemento de una lista; así que utilizamos mapcan para conseguirlo (ya que queremos los resultados de cada operación concatenados).

3.3
Lo primero que se nos pasa por la cabeza al pensar este ejercicio es utilizar reduce para reducir la lista con combine-lst-lst.
Imaginemos que implementamos la función así y se la aplicamos a ((a b) (+ -) (1 2)). La primera iteración de reduce daría como resultado ((a +) (a -) (b +) (b -)), y la siguiente tendría que volver a aplicar combine-lst-lst a este resultado y (1 2).
A primera vista parece que saldrá lo que queremos, pero lo que obtenemos es (((a +) 1) ((a +) 2) ((a -) 1) ...).
Nosotros querríamos exactamente este comportamiento, solo que en lugar de que se cree una nueva lista al combinar dos elementos, si el primero es una lista debería añadirse el segundo elemento al final.
Para conseguir esto, creamos una versión alternativa de combine-lst-lst y combine-elt-lst. La diferencia única diferencia entre estas versiones y las originales es que combine-elt-lst-alt comprueba si el elemento que se le pasa es una lista bien formada, y si lo es, le el elemento oportuno al final.
Por supuesto, para poder hacer esto, hemos tenido que implementar una función que comprobara si algo es una lista bien formada (ya que listp en realidad hace lo mismo que consp solo que devolviendo T para NIL).
Además, añadimos una condición extra en combine-list-of-lsts para que actúe correctamente cuando la lista de listas sólo contiene una lista.